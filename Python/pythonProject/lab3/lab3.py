
nums=[1,2,6,4,7,5,3]
# сортировка пузырьком
def BubbleSort(A):
    for i in range(len(A)):
        for j in range(len(A)-1-i):
            if A[j] > A[j+1]:
                a = A[j]
                A[j] = A[j+1]
                A[j+1] = a
BubbleSort(nums)
print(nums)

def hello(name):
    print("Hi "+name)
    print("Nice to see you again")
    print("Enjoy our video!")

print("---------------------")
hello("Aleks")
print("---------------------")
hello("Jane")


#------------------
def mySum(a, b):
    return a+b
a=23
b=799

print(f"Summ {a}  and {b} =" + str(mySum(a, b)))

#Создать функцию, которая будет переводить годы прожитые собакой в человеческие
def ageFrDogToPerson(age):
    if age<=1:
        return 14
    elif age==2:
        return 22
    else:
        return 22+(age-2)*5

print("My dogs Jack 5 years old and hi is person by " + str(ageFrDogToPerson(5)) +" years old")


print("--------------------------------------")
#------------------------------------------------
# определяем значение в ряду Фибоначчи
q=int(input("Введите порядковый номер в ряду Фибоначчи:"))
def fibonacci(n):
    if n in (1, 2):
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)

print(f"порядковому номеру {q} в ряду Фибоначчи соответствует значение: " + str(fibonacci(q)))


#-------------------------------------------------------------
# Функция map() выполняет пользовательскую функцию function для каждого элемента последовательности,
# коллекции или итератора iterable. Каждый элемент iterable отправляется в функцию function в
# качестве аргумента.

# Преимуществ использования map():

# Так как функция map() написана на языке C и хорошо оптимизирована, ее внутренний цикл более эффективный,
# чем обычный цикл for в Python.
# Низкое потребление памяти. С помощью цикла for .. in: программе необходимо хранить в памяти системы
# весь список элементов последовательности над которым производятся какие-то действия внутри цикла.
# При помощи функции map() элементы последовательности извлекаются по запросу, следовательно при
# каждом внутреннем цикле map() в памяти системы находится и обрабатывается только один элемент
# последовательности.

#Подсчет количества символов в каждом элементе кортежа:
x = map(len, ('apple', 'banana', 'cherry'))
print(list(x))
# [5, 6, 6]

#Создание словаря из двух списков.
x = map(lambda *args: args, [1, 2], [3, 4])
print(dict(x))
# {1: 3, 2: 4}

#Удаление пунктуации в тексте при помощи map().
import re
def clean(word):
    return re.sub(r"[`!?.:;,'\"()-]", "", word.strip())

text = """С помощью цикла `for .. in:` программе
необходимо хранить в памяти системы весь (список)! """
word = text.split()
word = map(clean, word)
text = ' '.join(word)
print(text)


#--------------------------------
#  Функция reduce()
#  from functools import reduce
#  reduce(function, iterable[, initializer])
# function - пользовательская функция, принимающая 2 аргумента,
# iterable - итерируемая последовательность,
# initializer - начальное значение.

#### Вычисление суммы всех элементов списка при помощи reduce() и lambda-функции:
from functools import reduce
items = [10, 20, 30, 40, 50]
print(reduce(lambda x,y: x + y, items))
# 150

####Вычисление наибольшего элемента в списке при помощи reduce():

from functools import reduce
items = [1, 24, 17, 14, 9, 32, 2]
print(reduce(lambda a,b: a if (a > b) else b, items))
# 32


# -------------------------------
# Функция zip()
# Функция zip объединяет в кортежи элементы из последовательностей переданных в качестве аргументов.
# Кортеж - неизменяемый список.


employee_numbers = [2, 9, 18, 28]
employee_names = ["Дима", "Марина", "Андрей", "Никита"]

zipped_values = zip(employee_names, employee_numbers)
zipped_list = list(zipped_values)

print(zipped_list)

######  БИБЛИОТЕКИ
import numpy
import Pandas
#пакет, предназначенный для простой и интуитивно понятной работы с реляционными данными.
# Тоже работает в связке с NumPy, и помимо математических вычислений обеспечивает их агрегацию
# и визуализацию


# import SciPy
#содержит модули для линейной алгебры, оптимизации, интеграции и статистики. SciPy работает совместно с NumPy, что позволяет ей значительно расширить функциональность. Два аргумента, почему эта библиотека действительно хороша:
#Наличие подпрограмм, таких как численная интеграция и оптимизация, для повышения производительности.
#Подробная документация на каждую функцию.

#  import Matplotlib
#С её помощью вы создадите:
#Линейные графики;
#Графики рассеяния;
#Гистограммы;
#Круговые диаграммы;
#Стволовые участки;
#Контурные участки;
#Участки колчана;
#Спектрограммы.

# import   SciKit-Learn
# инструмент для обработки изображений и имитации искусственного интеллекта.
# Он основывается на библиотеке SciPy и отвечает за реализацию алгоритмов машинного обучения.
# SciKit, как и его математическая основа, демонстрирует высокую производительность,
# и имеет качественную документацию.
