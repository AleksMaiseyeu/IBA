/* ЛР -7 Лекция + конспект
 Модели конкурентного доступа: (СЕРВЕР САМ ВЫБИРАЕТ МОДЕЛЬ)
 * пессимистический одновременный конкурентный доступ(при insert|update|delete)
   
   Предполагается, что между процессами в любое время может возникнуть конфликт 
   и ресурс блокируется

 * оптимистический одновременный конкурентный доступ (все хорошо)

   Предполагается, что одновременное изменение данных маловероятно

Транзакция
* Одна или несколько команд SQL, которые либо успешно выполняются как единое целое, 
  либо отменяются как единое целое

* Логическая единица работы, обеспечивающая переход базы данных из одного 
  согласованного состояния в другое согласованное состояние


  Транзакции:
  - Неявные
      задает любую отдельную инструкцию INSERT, UPDATE или DELETE как единицу транзакции
  - Явные
      группа инструкций, начало и конец которой обозначаются инструкциями:
        BEGIN TRANSACTION
        COMMIT
        ROLLBACK

ACID
Atomicity - Атомарность
   Выполняются или все изменения данных в транзакции или ни одна

Consistency - Согласованность
   Выполняемые транзакцией трансформации данных переводят базу данных из одного согласованного состояния в другое

Isolation - Изолированность
   Все параллельные транзакции отделяются друг от друга
   Активная транзакция не может видеть модификации данных в параллельной или незавершенной транзакции

Durability - Долговечность
   Транзакцию после фиксации нельзя отменить, кроме как другой транзакцией

=====================
    Инструкции
=====================
BEGIN TRANSACTION
BEGIN DISTRIBUTED TRANSACTION
   Запускается распределенная транзакция
   Управляется Microsoft Distributed Transaction Coordinator 
   Распределенная транзакция — это транзакция, которая используется на нескольких базах данных и на нескольких серверах
   Координатор - сервер, запустивший инструкцию BEGIN DISTRIBUTED TRANSACTION

COMMIT [WORK]
ROLLBACK [WORK]
  
SAVE TRANSACTION
  Точка сохранения определяет точку в транзакции, такую что все последующие изменения данных могут быть отменены без отмены всей транзакции
  SAVE TRANSACTION создает метку для последующей инструкции ROLLBACK, имеющей такую же метку, как и данная инструкция SAVE TRANSACTION

SET IMPLICIT_TRANSACTIONS ON/OFF
	Режим неявных транзакций
	Если транзакцию явно не зафиксировать, то все изменения, выполненные в ней, откатываются при отключении пользователя
	Любая из следующих инструкций запускает транзакцию:
	CREATE (ALTER, DROP, TRUNCATE ) TABLE
	OPEN FETCH 
	GRANT REVOKE
	INSERT DELETE UPDATE
	SELECT 

	SET IMPLICIT_TRANSACTIONS OFF

	BEGIN TRANSACTION
	COMMIT или ROLLBACK
	Явные транзакции можно вкладывать друг в друга
	Вложенные транзакции используются в хранимых процедурах, которые сами содержат транзакции и вызываются внутри другой транзакции
	@@TRANCOUNT содержит число активных транзакций для текущего пользователя

-------------------------
Журнал транзакций
-------------------------
	Журнал транзакций применяется для отката или восстановления транзакции
	Для каждой базы данных собственный журнал транзакций
	Database Engine сохраняет значения до и после транзакции в журналах транзакций (transaction log)
	Исходные образы записей (before image)
	Преобразованные образы записей (after image)
	LSN – порядковый номер для каждой записи
	Процессы:
	Процесс отмены записей (undo)
	Процесс повторного выполнения действий (redo)


------------
Блокировки  sys.dm_tran_locks
------------
	Блокировки – механизм обеспечения согласованности данных в случае одновременного обращения к данным нескольких пользователей

	Свойства:
	Длительность блокировки
	Режим блокировки
	Гранулярность блокировки

    Длительность блокировки — это период времени, в течение которого ресурс удерживает определенную блокировку

Режим блокировки:
* Разделяемая (shared lock)
	  Разделяемая блокировка резервирует ресурс только для чтения
	  Другие процессы не могут изменять заблокированный ресурс
	  Может быть несколько разделяемых блокировок

* Монопольная (exclusive lock)
	Монопольная блокировка резервирует страницу или строку для монопольного использования одной транзакции
	Применяется при INSERT, UPDATE и DELETE
	Монопольную блокировку нельзя установить, если на ресурс уже установлена какая-либо блокировка

* Обновления (update lock)
	Можно устанавливать на объекты с разделяемой блокировкой, накладывается еще одна разделяемая блокировка
	Нельзя устанавливать при наличии на нем другой блокировки обновления или монопольной блокировки
	При COMMIT транзакции обновления, блокировка обновления преобразовывается в монопольную блокировку
	У объекта может быть только одна блокировка обновления

	СУБД автоматически выбирает соответствующий режим блокировки, в зависимости от типа операции (чтение или запись)


Гранулярность блокировки
------------------------
Гранулярность блокировки определяет, какой объект блокируется:
строки
страницы
индексный ключ или диапазон индексных ключей
таблицы
экстент
база данных

СУБД выбирает гранулярность блокировки автоматически

Процесс преобразования большого числа блокировок уровня строки, страницы или индекса в одну блокировку уровня таблицы называется эскалацией блокировок (lock escalation)
ALTER TABLE 
SET (LOCK_ESCALATION = {TABLE | AUTO | DISABLE})
Подсказки блокировок (locking hints) 
SET LOCK_TIMEOUT - период в миллисекундах, в течение которого транзакция будет ожидать снятия блокировки с объекта (-1 по умолчанию, не установлен)

Взаимоблокировка (deadlock) — это особая проблема одновременного конкурентного доступа, в которой две транзакции блокируют друг друга

---------------
Уровни изоляции
* READ UNCOMMITTED
	Не изолирует операции чтения других транзакций
	Транзакция не задает и не признает блокировок
	Допускает проблемы:
	  -Грязное чтение
	  -Неповторяемое чтение 
	  -Фантомное чтение

	 READ COMMITTED
	    Транзакция выполняет проверку только на наличие монопольной блокировки для данной строки
		Является уровнем изоляции по умолчанию
		Проблемы:
		 -Неповторяемое чтение
		 -Фантомное чтение 

	 REPEATABLE READ
	    Устанавливает разделяемые блокировки на все считываемые данные и удерживает эти блокировки до тех пор, пока транзакция не будет подтверждена или отменена
		Не препятствует другим инструкциям вставлять новые строки
		Проблема:
		-Фантомное чтение

	 SERIALIZABLE
		Устанавливает блокировку на всю область данных, считываемых соответствующей транзакцией 
		Предотвращает вставку новых строк другой транзакцией до тех пор, пока первая транзакция не будет подтверждена или отменена

		Реализуется с использованием метода блокировки диапазона ключа
		Блокировка диапазона ключа блокирует элементы индексов

	 SNAPSHOT

Уровень изоляции задает степень защищенности данных в транзакции  от возможности изменения другими транзакциями

Проблемы:
	Потеря обновлений
		Несколько транзакций одновременно могут считывать и обновлять одни и те же данные
		Теряются все обновления данных, за исключением обновлений, выполненных последней транзакцией

	Грязное чтение
		Происходит чтение несуществующих данных или потеря модифицированных данных

	Неповторяемое чтение
		Один процесс считывает данные несколько раз, а другой процесс изменяет эти данные между двумя операциями чтения первого процесса
		Значения двух чтений будут разными

	Фантомное чтение
		Последовательные операции чтения могут возвратить разные значения
		Считывание разного числа строк при каждом чтении
		Возникают дополнительные фантомные строки, которые вставляются другими транзакциями


--------------------
Установка уровня изоляции
--------------------
SET TRANSACTION ISOLATION LEVEL:
	READ UNCOMMITTED
	READ COMMITTED
	REPEATABLE READ
	SERIALIZABLE


Управление версиями строк
	Механизм управления оптимистическим одновременным конкурентным доступом основан на управлении версиями строк
	Для всех изменений данных создаются и поддерживаются логические копии
	При каждом изменении строки СУБД сохраняет в tempdb исходный вид записи

	Каждая версия строки помечается порядковым номером транзакции (XSN — transaction sequence number)
	Самая последняя версия строки сохраняется в базе данных и соединяется в связанном списке с версией, сохраненной в tempdb

	Поддержка уровней изоляции READ COMMITTED SNAPSHOT и SNAPSHOT
	Создание в триггерах таблиц inserted и deleted



------------------------
READ COMMITTED SNAPSHOT
------------------------
Любая другая транзакция будет читать значения зафиксированные на момент начала этой 
транзакции
ALTER DATABASE
SET ISOLATION LEVEL 
READ COMMITTED SNAPSHOT

SNAPSHOT
Уровень изоляции на уровне транзакций
Любая другая транзакция будет читать подтвержденные значения в том виде, 
в каком они существовали непосредственно перед началом выполнения этой транзакции

На уровне базы данных включается 
 ALLOW_SNAPSHOT_ISOLATION

SET TRANSACTION ISOLATION LEVEL SNAPSHOT
*/





-- Сценарий А - изучение свойств транзакций
-- Запускаем два сценария параллельно, выполняем в двух окнах - по очереди по отметкам

INSERT INTO OFFICES VALUES (26, 'Warsaw', 'Eastern', 108, 72000.00, 81000.00);

----- Покажем, что уровень изолированности READ UNCOMMITTED допускает неподтвержденное чтение

-- 1
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
BEGIN TRAN
SELECT COUNT(*) FROM OFFICES -- запускаем транзакцию, Результат: 
 
--  3
SELECT COUNT(*) FROM OFFICES -- Результат: , налицо неподтвержденное чтение
 
-- 5
SELECT COUNT(*) FROM OFFICES -- Результат: , после отката транзакции В
COMMIT TRAN

----- Покажем, что уровень изолированности READ COMMITTED не допускает неподтвержденное чтение

-- 6
SET TRANSACTION ISOLATION LEVEL READ COMMITTED
BEGIN TRAN
SELECT COUNT(*) FROM OFFICES -- запускаем транзакцию, Результат: 
 
--  8
SELECT COUNT(*) FROM OFFICES -- Результат: ожидание, неподтвержденного чтения нет
 
-- 10
SELECT COUNT(*) FROM OFFICES -- сразу после отката транзакции В Результат: , 
COMMIT TRAN

----- Покажем, что уровень изолированности READ COMMITTED  допускает неповторяющееся чтение

-- 11
SET TRANSACTION ISOLATION LEVEL READ COMMITTED
BEGIN TRAN
SELECT COUNT(*) FROM OFFICES -- Результат: 
 
-- 13
SELECT COUNT(*) FROM OFFICES -- Результат: 
-- пока вторая транзакция удаляла запись, данные дважды прочитались по-разному.
COMMIT TRAN

----- Покажем, что уровень изолированности REPEATABLE READ не допускает неповторяющееся чтение
INSERT INTO OFFICES VALUES (26, 'Warsaw', 'Eastern', 108, 72000.00, 81000.00); -- вернем запись
-- 14
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
BEGIN TRAN
SELECT COUNT(*) FROM OFFICES -- Результат: 17
 
-- 16
COMMIT TRAN -- сразу после фиксации транзакции А в окне В 
--- Строк обработано:1 - прошло выполнение оператора удаления

----- Покажем, что уровень изолированности REPEATABLE READ  допускает проблему фантомных записей
INSERT INTO OFFICES VALUES (28, 'Moscow', 'Eastern', 108, 725000.00, 835915.00); -- вернем запись
-- 18
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
BEGIN TRAN
SELECT COUNT(*) FROM OFFICES -- Результат: 
 
-- 20
SELECT COUNT(*) FROM OFFICES -- Результат: 
--- в рамках одной транзакции А два результата
COMMIT TRAN

----- Покажем, что уровень изолированности SERIALIZABLE  не допускает проблему фантомных записей
-- 21
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
BEGIN TRAN
SELECT COUNT(*) FROM OFFICES -- Результат: 

--  23
COMMIT TRAN -- после выполнения этой команды в сценарии В - Строк обработано:1

-- Установим ALLOW_SNAPSHOT_ISOLATION
USE master
GO
ALTER DATABASE B_BSTU SET ALLOW_SNAPSHOT_ISOLATION ON 
GO

----- Покажем, что уровень изолированности SNAPSHOT не блокирует строки таблицы и при этом обеспечивает изолированность
-- 24
SET TRANSACTION ISOLATION LEVEL SNAPSHOT
BEGIN TRAN
SELECT COUNT(*) FROM OFFICES -- Результат: 
-- 26
SELECT COUNT(*) FROM OFFICES -- Результат: - результат прежний

-- 28
SELECT COUNT(*) FROM OFFICES -- Результат:  - а результат все равно прежний

-- 29
COMMIT -- накатываем транзакцию А
SELECT COUNT(*) FROM OFFICES -- Результат:  - изменился


-- неявная транзакция
create table WEATHER (w varchar(10) unique);

DECLARE @flag int = 2 ;
SET IMPLICIT_TRANSACTIONS ON;
INSERT weather VALUES ('Sun'), ('Rain'), ('Wind');
IF @flag = 1  COMMIT ELSE ROLLBACK; -- выполнится вставка в таблицу, если значение флага 1

SELECT * FROM weather;  -- проверка

INSERT weather VALUES ('Sun');

-- атомарность явной транзакции - выполняются все операторы или ни один

BEGIN TRY
	BEGIN TRANSACTION
	 DELETE  weather WHERE w = 'Sun';
	 INSERT weather VALUES ('Rain');
	 INSERT weather VALUES ('Rain');
	COMMIT TRAN               
END TRY
		
BEGIN CATCH
PRINT 'There is an error: '+ 
	  CASE
          WHEN error_number() = 2627 THEN 'All lines should be unique' 
          ELSE 'Error: '+ cast(error_number() as  varchar(5))+ error_message()  
	  END; 
	 IF @@trancount > 0 PRINT @@trancount ROLLBACK TRAN ; 	  
END CATCH

SELECT * FROM weather;

-- Создание контрольных точек
DECLARE @point VARCHAR(6)
BEGIN TRY
	BEGIN TRANSACTION
	 DELETE  weather WHERE w = 'Sun';
	 SET @point = 'point1'; 
	 SAVE TRAN @point;  
	 INSERT weather VALUES ('Rain');
	 SET @point = 'point2'; 
	 SAVE TRAN @point;  
	 INSERT weather VALUES ('Rain');
	COMMIT TRAN               
END TRY
		
BEGIN CATCH
PRINT 'There is an error: '+ 
	  CASE
          WHEN error_number() = 2627 THEN 'All lines should be unique' 
          ELSE 'Error: '+ cast(error_number() as  varchar(5))+ error_message()  
	  END; 
	 IF @@trancount > 0 
	 BEGIN
	   PRINT 'Control point: '+ @point;
	   ROLLBACK TRAN @point;                                  
	   COMMIT TRAN;                  
	END;     
   END CATCH;	  

SELECT * FROM weather;

--- Вложенные транзакции
PRINT 'TRANCOUNT 1 = ' + cast(@@TRANCOUNT as varchar (20)); 
BEGIN TRAN													--  ВНЕШНЯЯ ТРАНЗАКЦИЯ   
 INSERT weather VALUES ('Sun');
 PRINT 'TRANCOUNT 2 = ' + cast(@@TRANCOUNT as varchar (20)); 
 BEGIN TRAN													--  ВНУТРЕННЯЯ ТРАНЗАКЦИЯ  
	UPDATE weather SET w = 'Snow' WHERE w = 'Rain';
	PRINT 'TRANCOUNT 3 = ' + cast(@@TRANCOUNT as varchar (20)); 
 COMMIT;													--  ВНУТРЕННЯЯ ТРАНЗАКЦИЯ
 PRINT 'TRANCOUNT 4 = ' + cast(@@TRANCOUNT as varchar (20));                                               
 IF @@TRANCOUNT > 0  
ROLLBACK;													--  ВНЕШНЯЯ ТРАНЗАКЦИЯ 
PRINT 'TRANCOUNT 5 = ' + cast(@@TRANCOUNT as varchar (20));  




